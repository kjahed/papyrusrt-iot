// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SIGNAL_FBSCHEMA_H_
#define FLATBUFFERS_GENERATED_SIGNAL_FBSCHEMA_H_

#include "flatbuffers/flatbuffers.h"

namespace FBSchema {

struct Signal;

struct Obj;

struct Signal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PROTOCOL = 4,
    VT_NAME = 6,
    VT_SOURCESLOT = 8,
    VT_DESTINATIONSLOT = 10,
    VT_SOURCEPORT = 12,
    VT_DESTINATIONPORT = 14,
    VT_ISDESTINATIONINTERNAL = 16,
    VT_PARAMS = 18
  };
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *sourceSlot() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCESLOT);
  }
  const flatbuffers::String *destinationSlot() const {
    return GetPointer<const flatbuffers::String *>(VT_DESTINATIONSLOT);
  }
  int32_t sourcePort() const {
    return GetField<int32_t>(VT_SOURCEPORT, 0);
  }
  int32_t destinationPort() const {
    return GetField<int32_t>(VT_DESTINATIONPORT, 0);
  }
  bool isDestinationInternal() const {
    return GetField<uint8_t>(VT_ISDESTINATIONINTERNAL, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<Obj>> *params() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Obj>> *>(VT_PARAMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffsetRequired(verifier, VT_SOURCESLOT) &&
           verifier.Verify(sourceSlot()) &&
           VerifyOffsetRequired(verifier, VT_DESTINATIONSLOT) &&
           verifier.Verify(destinationSlot()) &&
           VerifyField<int32_t>(verifier, VT_SOURCEPORT) &&
           VerifyField<int32_t>(verifier, VT_DESTINATIONPORT) &&
           VerifyField<uint8_t>(verifier, VT_ISDESTINATIONINTERNAL) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.Verify(params()) &&
           verifier.VerifyVectorOfTables(params()) &&
           verifier.EndTable();
  }
};

struct SignalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(Signal::VT_PROTOCOL, protocol);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Signal::VT_NAME, name);
  }
  void add_sourceSlot(flatbuffers::Offset<flatbuffers::String> sourceSlot) {
    fbb_.AddOffset(Signal::VT_SOURCESLOT, sourceSlot);
  }
  void add_destinationSlot(flatbuffers::Offset<flatbuffers::String> destinationSlot) {
    fbb_.AddOffset(Signal::VT_DESTINATIONSLOT, destinationSlot);
  }
  void add_sourcePort(int32_t sourcePort) {
    fbb_.AddElement<int32_t>(Signal::VT_SOURCEPORT, sourcePort, 0);
  }
  void add_destinationPort(int32_t destinationPort) {
    fbb_.AddElement<int32_t>(Signal::VT_DESTINATIONPORT, destinationPort, 0);
  }
  void add_isDestinationInternal(bool isDestinationInternal) {
    fbb_.AddElement<uint8_t>(Signal::VT_ISDESTINATIONINTERNAL, static_cast<uint8_t>(isDestinationInternal), 0);
  }
  void add_params(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Obj>>> params) {
    fbb_.AddOffset(Signal::VT_PARAMS, params);
  }
  explicit SignalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignalBuilder &operator=(const SignalBuilder &);
  flatbuffers::Offset<Signal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Signal>(end);
    fbb_.Required(o, Signal::VT_PROTOCOL);
    fbb_.Required(o, Signal::VT_NAME);
    fbb_.Required(o, Signal::VT_SOURCESLOT);
    fbb_.Required(o, Signal::VT_DESTINATIONSLOT);
    return o;
  }
};

inline flatbuffers::Offset<Signal> CreateSignal(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> sourceSlot = 0,
    flatbuffers::Offset<flatbuffers::String> destinationSlot = 0,
    int32_t sourcePort = 0,
    int32_t destinationPort = 0,
    bool isDestinationInternal = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Obj>>> params = 0) {
  SignalBuilder builder_(_fbb);
  builder_.add_params(params);
  builder_.add_destinationPort(destinationPort);
  builder_.add_sourcePort(sourcePort);
  builder_.add_destinationSlot(destinationSlot);
  builder_.add_sourceSlot(sourceSlot);
  builder_.add_name(name);
  builder_.add_protocol(protocol);
  builder_.add_isDestinationInternal(isDestinationInternal);
  return builder_.Finish();
}

inline flatbuffers::Offset<Signal> CreateSignalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *protocol = nullptr,
    const char *name = nullptr,
    const char *sourceSlot = nullptr,
    const char *destinationSlot = nullptr,
    int32_t sourcePort = 0,
    int32_t destinationPort = 0,
    bool isDestinationInternal = false,
    const std::vector<flatbuffers::Offset<Obj>> *params = nullptr) {
  return FBSchema::CreateSignal(
      _fbb,
      protocol ? _fbb.CreateString(protocol) : 0,
      name ? _fbb.CreateString(name) : 0,
      sourceSlot ? _fbb.CreateString(sourceSlot) : 0,
      destinationSlot ? _fbb.CreateString(destinationSlot) : 0,
      sourcePort,
      destinationPort,
      isDestinationInternal,
      params ? _fbb.CreateVector<flatbuffers::Offset<Obj>>(*params) : 0);
}

struct Obj FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4,
    VT_FIELDS = 6
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Obj>> *fields() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Obj>> *>(VT_FIELDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.Verify(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           verifier.EndTable();
  }
};

struct ObjBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Obj::VT_DATA, data);
  }
  void add_fields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Obj>>> fields) {
    fbb_.AddOffset(Obj::VT_FIELDS, fields);
  }
  explicit ObjBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjBuilder &operator=(const ObjBuilder &);
  flatbuffers::Offset<Obj> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Obj>(end);
    return o;
  }
};

inline flatbuffers::Offset<Obj> CreateObj(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Obj>>> fields = 0) {
  ObjBuilder builder_(_fbb);
  builder_.add_fields(fields);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Obj> CreateObjDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr,
    const std::vector<flatbuffers::Offset<Obj>> *fields = nullptr) {
  return FBSchema::CreateObj(
      _fbb,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0,
      fields ? _fbb.CreateVector<flatbuffers::Offset<Obj>>(*fields) : 0);
}

inline const FBSchema::Signal *GetSignal(const void *buf) {
  return flatbuffers::GetRoot<FBSchema::Signal>(buf);
}

inline bool VerifySignalBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<FBSchema::Signal>(nullptr);
}

inline void FinishSignalBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FBSchema::Signal> root) {
  fbb.Finish(root);
}

}  // namespace FBSchema

#endif  // FLATBUFFERS_GENERATED_SIGNAL_FBSCHEMA_H_
